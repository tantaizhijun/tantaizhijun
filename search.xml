<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java线程池实现原理]]></title>
    <url>%2F2019%2F04%2F14%2Fjava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.如何自己实现一个线程池实现线程池需要准备的东西 存放线程的集合： 存放任务的队列：每有一个任务分配给线程池，我们就从线程池中分配一个线程处理它。但当线程池中的线程都在运行状态，没有空闲线程时，我们还需要一个队列来存储提交给线程池的任务。另外还有，初始化线程池，是否要指定线程池的大小？要保存当前运行线程的数目等。 1234567891011/**存放线程的集合*/private ArrayList&lt;MyThead&gt; threads;/**任务队列*/private ArrayBlockingQueue&lt;Runnable&gt; taskQueue;/**线程池初始限定大小*/private int threadNum;/**已经工作的线程数目*/private int workThreadNum; 线程池的核心方法接下来就是线程池的核心方法，每当向线程池提交一个任务时。如果 已经运行的线程&lt;线程池大小，则创建一个线程运行任务，并把这个线程放入线程池；否则将任务放入缓冲队列中。123456789101112131415161718192021public void execute(Runnable runnable) &#123; try &#123; mainLock.lock(); //线程池未满，每加入一个任务则开启一个线程 if(workThreadNum &lt; threadNum) &#123; MyThead myThead = new MyThead(runnable); myThead.start(); threads.add(myThead); workThreadNum++; &#125; //线程池已满，放入任务队列，等待有空闲线程时执行 else &#123; //队列已满，无法添加时，拒绝任务 if(!taskQueue.offer(runnable)) &#123; rejectTask(); &#125; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; 到这里，一个线程池已经实现的差不多了，我们还有最后一个难点要解决：从任务队列中取出任务，分配给线程池中“空闲”的线程完成. 分配任务给线程的实现思路 思路1：额外开启一个线程，时刻监控线程池的线程空余情况，一旦有线程空余，则马上从任务队列取出任务，交付给空余线程完成。这种思路理解起来很容易，但仔细思考，实现起来很麻烦(麻烦如下：), 而且使线程池的架构变的更复杂和不优雅。 如何检测到线程池中的空闲线程 如何将任务交付给一个.start()运行状态中的空闲线程。 思路2:线程池中的所有线程一直都是运行状态的，线程的空闲只是代表此刻它没有在执行任务而已；我们可以让运行中的线程，一旦没有执行任务时，就自己从队列中取任务来执行。 为了达到这种效果，我们要重写run方法，所以要写一个自定义Thread类，然后让线程池都放这个自定义线程类 123456789101112131415161718192021222324class MyThead extends Thread&#123; private Runnable task; public MyThead(Runnable runnable) &#123; this.task = runnable; &#125; @Override public void run() &#123; //该线程一直启动着，不断从任务队列取出任务执行 while (true) &#123; //如果初始化任务不为空，则执行初始化任务 if(task != null) &#123; task.run(); task = null; &#125; //否则去任务队列取任务并执行 else &#123; Runnable queueTask = taskQueue.poll(); if(queueTask != null) queueTask.run(); &#125; &#125; &#125; &#125; 简单线程池的实现源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 自定义简单线程池 */public class MyThreadPool&#123; /**存放线程的集合*/ private ArrayList&lt;MyThead&gt; threads; /**任务队列*/ private ArrayBlockingQueue&lt;Runnable&gt; taskQueue; /**线程池初始限定大小*/ private int threadNum; /**已经工作的线程数目*/ private int workThreadNum; private final ReentrantLock mainLock = new ReentrantLock(); public MyThreadPool(int initPoolNum) &#123; threadNum = initPoolNum; threads = new ArrayList&lt;&gt;(initPoolNum); //任务队列初始化为线程池线程数的四倍 taskQueue = new ArrayBlockingQueue&lt;&gt;(initPoolNum*4); threadNum = initPoolNum; workThreadNum = 0; &#125; public void execute(Runnable runnable) &#123; try &#123; mainLock.lock(); //线程池未满，每加入一个任务则开启一个线程 if(workThreadNum &lt; threadNum) &#123; MyThead myThead = new MyThead(runnable); myThead.start(); threads.add(myThead); workThreadNum++; &#125; //线程池已满，放入任务队列，等待有空闲线程时执行 else &#123; //队列已满，无法添加时，拒绝任务 if(!taskQueue.offer(runnable)) &#123; rejectTask(); &#125; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125; private void rejectTask() &#123; System.out.println(&quot;任务队列已满，无法继续添加，请扩大您的初始化线程池！&quot;); &#125; public static void main(String[] args) &#123; MyThreadPool myThreadPool = new MyThreadPool(5); Runnable task = new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+&quot;执行中&quot;); &#125; &#125;; for (int i = 0; i &lt; 20; i++) &#123; myThreadPool.execute(task); &#125; &#125; class MyThead extends Thread&#123; private Runnable task; public MyThead(Runnable runnable) &#123; this.task = runnable; &#125; @Override public void run() &#123; //该线程一直启动着，不断从任务队列取出任务执行 while (true) &#123; //如果初始化任务不为空，则执行初始化任务 if(task != null) &#123; task.run(); task = null; &#125; //否则去任务队列取任务并执行 else &#123; Runnable queueTask = taskQueue.poll(); if(queueTask != null) queueTask.run(); &#125; &#125; &#125; &#125;&#125; 总结一下，这个自定义线程池的整个工作过程： 初始化线程池，指定线程池的大小。 向线程池中放入任务执行。 如果线程池中创建的线程数目未到指定大小，则创建我们自定义的线程类放入线程池集合，并执行任务。执行完了后该线程会一直监听队列 如果线程池中创建的线程数目已满，则将任务放入缓冲任务队列 线程池中所有创建的线程，都会一直从缓存任务队列中取任务，取到任务马上执行 #———————-第二部分：java线程池实现原理—————– 2. java线程池实现原理 java线程池的实现原理很简单，就是一个线程集合workerSet和一个阻塞队列workQueue。 当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。 workerSet中的线程会不断的从workQueue中获取线程然后执行。 当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。 ####线程池的几个重要参数1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); 注解： corePoolSize: 规定线程池有几个线程(worker)在运行。 maximumPoolSize: 当workQueue满了,不能添加任务的时候，这个参数才会生效。规定线程池最多只能有多少个线程(worker)在执行。 keepAliveTime: 超出corePoolSize大小的那些线程的生存时间,这些线程如果长时间没有执行任务并且超过了keepAliveTime设定的时间，就会消亡。 unit: 生存时间对于的单位 workQueue: 存放任务的队列 threadFactory: 创建线程的工厂 handler: 当workQueue已经满了，并且线程池线程数已经达到maximumPoolSize，将执行拒绝策略。 任务提交后的流程分析用户通过submit提交一个任务。线程池会执行如下流程: 判断当前运行的worker数量是否超过corePoolSize,如果不超过corePoolSize。就创建一个worker直接执行该任务。—— 线程池最开始是没有worker在运行的 如果正在运行的worker数量超过或者等于corePoolSize,那么就将该任务加入到workQueue队列中去。 如果workQueue队列满了,也就是offer方法返回false的话，就检查当前运行的worker数量是否小于maximumPoolSize,如果小于就创建一个worker直接执行该任务。 如果当前运行的worker数量是否大于等于maximumPoolSize，那么就执行RejectedExecutionHandler来拒绝这个任务的提交。 源码解析ThreadPoolExecutor中的几个关键属性123456789101112131415161718192021222324//这个属性是用来存放 当前运行的worker数量以及线程池状态的//int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//存放任务的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;//worker的集合,用set来存放private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//历史达到的worker数最大值private int largestPoolSize;//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略private volatile RejectedExecutionHandler handler;//超出coreSize的worker的生存时间private volatile long keepAliveTime;//常驻worker的数量private volatile int corePoolSize;//最大worker的数量,一般当workQueue满了才会用到这个参数private volatile int maximumPoolSize; 提交任务相关源码execute()方法的源码：12345678910111213141516171819202122232425262728public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //workerCountOf(c)会获取当前正在运行的worker数量 if (workerCountOf(c) &lt; corePoolSize) &#123; //如果workerCount小于corePoolSize,就创建一个worker然后直接执行该任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; //isRunning(c)是判断线程池是否在运行中,如果线程池被关闭了就不会再接受任务 //后面将任务加入到队列中 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //如果添加到队列成功了,会再检查一次线程池的状态 int recheck = ctl.get(); //如果线程池关闭了,就将刚才添加的任务从队列中移除 if (! isRunning(recheck) &amp;&amp; remove(command)) //执行拒绝策略 reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果加入队列失败,就尝试直接创建worker来执行任务 else if (!addWorker(command, false)) //如果创建worker失败,就执行拒绝策略 reject(command);&#125; 添加worker的方法addWorker()源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: //使用自旋+cas失败重试来保证线程竞争问题 for (;;) &#123; //先获取线程池的状态 int c = ctl.get(); int rs = runStateOf(c); // 如果线程池是关闭的,或者workQueue队列非空,就直接返回false,不做任何处理 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //根据入参core 来判断可以创建的worker数量是否达到上限,如果达到上限了就拒绝创建worker if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //没有的话就尝试修改ctl添加workerCount的值。这里用了cas操作,如果失败了下一个循环会继续重试,直到设置成功 if (compareAndIncrementWorkerCount(c)) //如果设置成功了就跳出外层的那个for循环 break retry; //重读一次ctl,判断如果线程池的状态改变了,会再重新循环一次 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; final ReentrantLock mainLock = this.mainLock; //创建一个worker,将提交上来的任务直接交给worker w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //加锁,防止竞争 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); //还是判断线程池的状态 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; //如果worker的线程已经启动了,会抛出异常 if (t.isAlive()) throw new IllegalThreadStateException(); //添加新建的worker到线程池中 workers.add(w); int s = workers.size(); //更新历史worker数量的最大值 if (s &gt; largestPoolSize) largestPoolSize = s; //设置新增标志位 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //如果worker是新增的,就启动该线程 if (workerAdded) &#123; t.start(); //成功启动了线程,设置对应的标志位 workerStarted = true; &#125; &#125; &#125; finally &#123; //如果启动失败了,会触发执行相应的方法 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; Worker的结构Worker是ThreadPoolExecutor内部定义的一个内部类。我们先看一下Worker的继承关系 1private final class Worker extends AbstractQueuedSynchronizer implements Runnable 它实现了Runnable接口,所以可以拿来当线程用。同时它还继承了AbstractQueuedSynchronizer同步器类,主要用来实现一个不可重入的锁。 一些属性还有构造方法:123456789101112//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个workerfinal Thread thread;//当一个worker刚创建的时候,就先尝试执行这个任务Runnable firstTask;//记录完成任务的数量volatile long completedTasks;Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; //创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法 this.thread = getThreadFactory().newThread(this);&#125; worker的run()方法：1234public void run() &#123; //这里调用了ThreadPoolExecutor的runWorker方法 runWorker(this);&#125; ThreadPoolExecutor的runWorker方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final void runWorker(Worker w) &#123; //获取当前线程 Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; //执行unlock方法,允许其他线程来中断自己 w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //如果前面的firstTask有值,就直接执行这个任务 //如果没有具体的任务,就执行getTask()方法从队列中获取任务 //这里会不断执行循环体,除非线程中断或者getTask()返回null才会跳出这个循环 while (task != null || (task = getTask()) != null) &#123; //执行任务前先锁住,这里主要的作用就是给shutdown方法判断worker是否在执行中的 //shutdown方法里面会尝试给这个线程加锁,如果这个线程在执行,就不会中断它 w.lock(); //判断线程池状态,如果线程池被强制关闭了,就马上退出 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //执行任务前调用。预留的方法,可扩展 beforeExecute(wt, task); Throwable thrown = null; try &#123; //真正的执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //执行任务后调用。预留的方法,可扩展 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; //记录完成的任务数量 w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出线程池是怎么让超过corePoolSize的那部分worker销毁的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Runnable getTask() &#123; boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // 如果线程池已经关闭了,就直接返回null, //如果这里返回null,调用的那个worker就会跳出while循环,然后执行完销毁线程 //SHUTDOWN状态表示执行了shutdown()方法 //STOP表示执行了shutdownNow()方法 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; //获取当前正在运行中的worker数量 int wc = workerCountOf(c); // 如果设置了核心worker也会超时或者当前正在运行的worker数量超过了corePoolSize,就要根据时间判断是否要销毁线程了 //其实就是从队列获取任务的时候要不要设置超时间时间,如果超过这个时间队列还没有任务进来,就会返回null boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //如果上一次循环从队列获取到的未null,这时候timedOut就会为true了 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //通过cas来设置WorkerCount,如果多个线程竞争,只有一个可以设置成功 //最后如果没设置成功,就进入下一次循环,说不定下一次worker的数量就没有超过corePoolSize了,也就不用销毁worker了 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //如果要设置超时时间,就设置一下咯 //过了这个keepAliveTime时间还没有任务进队列就会返回null,那worker就会销毁 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; //如果r为null,就设置timedOut为true timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 添加Callable任务的实现源码123456public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125; 要添加一个有返回值的任务的实现也很简单。其实就是对任务做了一层封装，将其封装成Future，然后提交给线程池执行，最后返回这个future。这里的 newTaskFor(task) 方法会将其封装成一个FutureTask类。外部的线程拿到这个future，执行get()方法的时候,如果任务本身没有执行完，执行线程就会被阻塞，直到任务执行完。下面是FutureTask的get方法12345678public V get() throws InterruptedException, ExecutionException &#123; int s = state; //判断状态,如果任务还没执行完,就进入休眠,等待唤醒 if (s &lt;= COMPLETING) s = awaitDone(false, 0L); //返回值 return report(s);&#125; FutureTask中通过一个state状态来判断任务是否完成。当run方法执行完后,会将state状态置为完成，同时唤醒所有正在等待的线程。我们可以看一下FutureTask的run()方法:12345678910111213141516171819202122232425262728293031public void run() &#123; //判断线程的状态 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; //执行call方法 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) //这个方法里面会设置返回内容,并且唤醒所以等待中的线程 set(result); &#125; &#125; finally &#123; runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; shutdown和shutdownNow方法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查是否可以关闭线程 checkShutdownAccess(); //设置线程池状态 advanceRunState(SHUTDOWN); //尝试中断worker interruptIdleWorkers(); //预留方法,留给子类实现 onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125;private void interruptIdleWorkers() &#123; interruptIdleWorkers(false);&#125;private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历所有的worker for (Worker w : workers) &#123; Thread t = w.thread; //先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它 //注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能 //它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125; shutdownNow()做的比较绝，它先将线程池状态设置为STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的worker,然后清空任务队列。 123456789101112131415161718192021222324252627282930public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //检测权限 advanceRunState(STOP); //中断所有的worker interruptWorkers(); //清空任务队列 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125;private void interruptWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历所有worker，然后调用中断方法 for (Worker w : workers) w.interruptIfStarted(); &#125; finally &#123; mainLock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略（jvm第三章）]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88jvm%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.那些对象需要回收？如何判断对象是垃圾需要回收呢？一般有两种方式： 引用计数器算法 给对象添加一个引用计数器，每当一个地方引用时，计数器就加一，当引用失效时减一， 任何时刻计数器为0的对象就是不可能再被引用的， 主流的java虚拟机都不用此算法。 特点：实现简单，判定效率也很高. 缺点：很难解决对象之间的互相循环引用的问题 可达性算法 基本思路是：通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索， 搜索走过的路径成为引用链，当一个对象到“GC Roots”没有任何引用链相连（即从GC Roots到这个对象不可达）时， 则证明此对象是不可用的。 可作为GC Roots的对象有： .虚拟机栈中（栈桢中的本地变量表）引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象 本地方法栈中JNI（一般说的native方法）引用的对象 2.说说“引用” 上面判断对象是否有用的方法，都与引用有关，但何为引用呢？ JDK1.2以前的定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。 这种定义太狭隘，即一个对象只有被引用和没有引用两种状态，对于一些没有大用处的对象来说，此定义就显得无力。 比较好的描述是：当内存足够时，则能保留在内存中，如果内存紧张，进行垃圾回收后还非常紧张，则抛弃这些对象。 JDK1.2以后，对引用概念进行了扩充，将引用分为： 强引用 软引用 弱引用 虚引用 强引用：即指的普遍存在的对象，如new出来的引用，只有强引用在，就不会回收。 软引用：有用，但不是必须的对象。在内存溢出之前，会把他们列入回收范围之中进行第二次回收，如果这次回收还没有足够内存，才会抛出异常 弱引用：非必须的对象，强度比弱引用更弱，被弱引用引用的对象只能生存到下一次垃圾回收发生之前，当垃圾回首时，无论内存是否足够，都会回收掉他们。 虚引用：也叫幽灵引用或幻影引用，这些对象是否有虚引用的存在，不会对生存时间构成影响，也无法通过虚引用获取实例，唯一的目的就是垃圾回收时能收到一个系统通知。 3.被“可达性算法”分析之后，就会一定被回收吗？ 即使在可达性算法分析中，那些不可达的对象，也不一定“非死不可”，还处于“缓刑”阶段，宣告他们的死亡，还要经过 “两次标记” 的过程： 第一次标记：如果在可达性算法分析时发现没有与GC Roots相连，会被第一次标记，然后进行一次筛选。筛选的条件是： 此对象 有没有必要 执行finalize()方法。 问：什么时候没有必要执行呢，2种情况被视为没有必要： - 当对象没有重写了finalize()方法，被视为没必要。 - 重写了该方法，但虚拟机调用过一次，被视为没必要。 如果有必要执行finalize()，则将对象放到F-Queue队列中，稍后有虚拟机自建一个低优先级的线程去执行，会触发这个finalize()方法，但不一定承诺等他执行结束哦， 如果想在finalize()中成功拯救自己，则需要该对象重新与引用链任何一个对象建立关联即可，否则自救失败。 第二次标记：稍后GC将对F-Queue里的对象进行第二次标记，那些成功自救的对象，会在这次标记时被移除“即将回收”的集合。 4.垃圾收集算法1.标记-清除算法 首先标记出需要回收的对象（就是上面说的两次标记），标记完成后统一回收被标记的对象。 这是最基础的垃圾收集算法，之后的算法都是对它的不足进行改进而来的。 不足之处： 一是效率问题：标记和清除的两个过程效率都不高， 二是空间问题：清除完成后，内存分片太多，不连续，如果需要分配大对象（如大数组），可能找不到足够的连续空间，而不得不再进行一次垃圾收集动作。 2.复制算法 他的原理是： 将内存按容量划分为大小相同的两个区域，每次只使用其中一个区域，当这块快用完了时，将还存活的对象复制到另一块区域上，然后对这块区域进行一次清理掉。 缺点： 每次只使用一半的空间，太浪费了好吗，我买的8G，你只给我使用4G？？？ 另外，复制收集算法在对象存活率较高时，需要复制的对象就多了，效率就会降低，更关键的是，如果不想浪费更多的空间，复制空间划分的小了，就需要额外的空间进行分配担保，以应对很多对象都存活的极端情况。 所以老年代一般不采用这种算法， 注： 现在的商用虚拟机都采用这种回收算法来回收新生代，当然不是按一半一半进行划分使用的啦，新生代的对象98%都是“朝生夕死”，所以不需要1：1对半划分， 划分方式：划分一个较大的Eden空间 和 两个小的survivor空间，按 8:1:1 划分。 每次使用较大的Eden空间和一个小的Survivor空间，当回收时，把活着的对象，复制到另一个小的Survivor上面，然后清理掉Eden空间和刚才用过的小Survivor空间。 然后使用的时候继续使用大的Eden空间和刚复制的小的survivor空间，依次类推. 这样，每次其实是使用了80%+10%=90%的空间，只浪费了10%的空间。还可以啦。 问：如果复制的时候，那个小的Survivor空间不够用怎么办？ 答：问的好，我们没有办法保证每次回收都只有不到10%的对象存活，如果存活的多了，survivor空间就不够了， 就需要依赖其他内存（这里指老年代）进行“分配担保”。 3.标记-整理算法 标记的过程与“标记-清除算法”的一样，但后续不同，他是让存活的对象，都向一端移动，然后直接清理掉端边界以外的内存。 4.分代收集算法 当前商用虚拟机都采用这种算法，就是根据对象存活周期不同把内存划分为几块； 不同的对象的生命周期是不一样的，因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。 比如：Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。 而程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 因此，对不同生命周期的对象进行分代存放，不同代上采用最适合它的垃圾回收方式进行回收。 一般把java堆划分为新生代和老年代，然后根据各个年代的特点，采用不同的垃圾收集算法。 新生代：采用复制算法，因为每次收集一般都有大批对象死亡，需要复制的存活对象较少。新生代分三个区。一个Eden区，两个Survivor区(一般而言)。所有新生成的对象首先都是放在年轻代的。 老年代：采用标记-整理或标记-清除算法。因为对象存活率高，没有额外空间进行分配担保。在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 持久代：也就是方法区，主要存放的是Java类的类信息，如Java类、方法等，与垃圾收集要收集的Java对象关系不大。持久代大小通过-XX:MaxPermSize=进行设置。 什么时候触发垃圾回收？ 由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。 Scavenge GC:一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。 Full GC: 对整个堆进行整理，包括Young、Tenured和Perm。因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： 老年代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显示调用 上一次GC之后Heap的各域分配策略动态变化 5.HotSpot算法实现 可作为GC Roots的节点主要在全局性的引用种，如常量和类静态属性，还有执行上下文（如栈桢中的本地变量表），现在的应用都很大，这些节点也很多，要遍历检查一遍，会消耗很多时间。 另外，可达性分析时还要发生GC停顿 ，这项工作必须在一个能确保一致性的快照上进行，就好比系统被冻结在某个瞬间，不可以出现引用的不断变化， 如果不能保证一致性，分析就不准确，因此，一致性是导致GC停顿的重要原因，即停止所有线程的运行，Stop The World！ 安全点 没有必要一个不漏的检查一遍执行上下文和全局的引用位置， HotSpot在特定的位置记录一些信息，存在OopMap中，这个OopMap记录了栈和寄存器中哪些位置是引用。 在OopMp的协助下，Hotspot可以快速准确的完成GC Roots枚举， 但是，不能给每个指令都生成一个OopMap，只在“特定的位置”记录就可以了，这个位置就是 “安全点” 即程序执行到安全点时才能暂停下来，进行GC， 安全点不能太多，会增大运行时的负荷，GC太频繁 安全点也不能太少，这样GC等待的时间就会过长， 安全点选定标准：基本上是以“是否具有让程序长时间执行的特征”为标准选的的，一般如方法调用，循环跳转，异常跳转等，这些指令才会产生安全点GC发生时，怎样让线程都跑到安全点？两种方案: 抢断式中断： Gc发生时，首先把线程全部中断，不需要线程配合，如果有不在安全点的，恢复运行，让他跑到安全点。 主动式中断： GC需要中断时，设置一个标志，不直接中断线程，各个线程运行时去轮询这个标志，为真时，就自己中断，轮询标志的地方和安全点是重合的。 安全区域 科技感科技 6.垃圾收集器回收器选择 JVM给了三种选择：串行收集器、并行收集器、并发收集器 7.内存分配（针对分代垃圾回收算法来说） 年轻代的设置很关键。 JVM中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。 32位系统下，一般限制在1.5G~2G； 64为操作系统对内存无限制。 在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。 典型设置： java -Xmx3550m -Xms3550m -Xmn2g –Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0 -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置持久代大小为16m。 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 未完待续。。。。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring mvc拦截器工作原理]]></title>
    <url>%2F2019%2F03%2F31%2Fspring-mvc%E6%8B%A6%E6%88%AA%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.spring mvc拦截器简介 Spring Web MVC的处理器拦截器（如无特殊说明，下文所说的拦截器即处理器拦截器）类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 2.应用场景 1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。 2、权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面； 3、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）； 4、通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。 5、OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。 …………本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。 拦截器工作方式 3.拦截器实现3.1 springMVC拦截器的实现一般有两种方式： 第一种方式是要定义的Interceptor类要实现了Spring的HandlerInterceptor 接口 第二种方式是继承实现了HandlerInterceptor接口的类，比如Spring已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter 3.2拦截器接口： 123456789101112package org.springframework.web.servlet; public interface HandlerInterceptor &#123; boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception; void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception; void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125; 方法说明： HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。 preHandle()： 这个方法在业务处理器处理请求之前被调用，SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。 postHandle()： 这个方法在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行。 afterCompletion()： 整个请求处理完毕回调方法，即在视图渲染完毕时回调，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 4.看一下DispatcherServlet内部到底是如何工作的注： 以下是流程的简化代码，中间省略了部分代码，不完整。1234567891011121314151617181920212223242526272829303132333435//doDispatch方法 //1、处理器拦截器的预处理（正序执行） HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); if (interceptors != null) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) &#123; //1.1、失败时触发afterCompletion的调用 triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null); return; &#125; interceptorIndex = i;//1.2、记录当前预处理成功的索引 &#125; &#125; //2、处理器适配器调用我们的处理器 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); //当我们返回null或没有返回逻辑视图名时的默认视图名翻译（详解4.15.5 RequestToViewNameTranslator） if (mv != null &amp;&amp; !mv.hasView()) &#123; mv.setViewName(getDefaultViewName(request)); &#125; //3、处理器拦截器的后处理（逆序） if (interceptors != null) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv); &#125; &#125; //4、视图的渲染 if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, processedRequest, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; //5、触发整个请求处理完毕回调方法afterCompletion triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null); triggerAfterCompletion方法 12345678910111213141516171819// triggerAfterCompletion方法 private void triggerAfterCompletion(HandlerExecutionChain mappedHandler, int interceptorIndex, HttpServletRequest request, HttpServletResponse response, Exception ex) throws Exception &#123; // 5、触发整个请求处理完毕回调方法afterCompletion （逆序从1.2中的预处理成功的索引处的拦截器执行） if (mappedHandler != null) &#123; HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); if (interceptors != null) &#123; for (int i = interceptorIndex; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; try &#123; interceptor.afterCompletion(request, response, mappedHandler.getHandler(), ex); &#125; catch (Throwable ex2) &#123; logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2); &#125; &#125; &#125; &#125; &#125; 5.拦截方式可以利用mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，先声明的拦截器中的preHandle方法会先执行，然而它的postHandle方法和afterCompletion方法却会后执行。 5.1 方式一：总拦截器，拦截所有url定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。 123&lt;mvc:interceptors&gt; &lt;bean class=&quot;com.app.mvc.MyInteceptor&quot; /&gt;&lt;/mvc:interceptors&gt; 5.2 方式二：总拦截器， 拦截匹配的URL12345678910111213141516&lt;mvc:interceptors &gt; &lt;mvc:interceptor&gt; &lt;!-- /** 的意思是所有文件夹及里面的子文件夹 /* 是所有文件夹，不含子文件夹 / 是web项目的根目录 --&gt; &lt;mvc:mapping path=&quot;/user/*&quot; /&gt; &lt;!-- 需排除拦截的地址 --&gt; &lt;mvc:exclude-mapping path=&quot;/user/b&quot; /&gt; &lt;bean class=&quot;com.mvc.MyInteceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;!-- 当设置多个拦截器时，先按顺序调用preHandle方法，然后逆序调用每个拦截器的postHandle和afterCompletion方法 --&gt;&lt;/mvc:interceptors&gt; 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。 mapping只能映射某些需要拦截的请求，而exclude-mapping用来排除某些特定的请求映射。当我们需要拦截的请求映射是比较通用的，但是其中又包含了某个特殊的请求是不需要使用该拦截器的时候我们就可以把它定义为exclude-mapping了。比如像下面示例这样，我们定义的拦截器将拦截所有匹配/user/**模式的请求，但是不能拦截请求“/user/b”，因此它定义为了exclude-mapping。当定义了exclude-mapping时，Spring MVC将优先判断一个请求是否在execlude-mapping定义的范围内，如果在则不进行拦截。 实际上一个interceptor下面定义的mapping和exclude-mapping都是可以有多个的。 另外，exclude-mapping的定义规则和mapping的定义规则是一样的，我们也可以使用一个星号表示任意字符，使用两个星号表示任意层次的任意字符。 注： 如果使用了&lt;mvc:annotation-driven /&gt;， 它会自动注册DefaultAnnotationHandlerMapping 与AnnotationMethodHandlerAdapter 这两个bean,所以就没有机会再给它注入interceptors属性，就无法指定拦截器。 当然我们可以通过人工配置上面的两个Bean，不使用 &lt;mvc:annotation-driven /&gt;，就可以 给interceptors属性 注入拦截器了 6. 对静态资源不拦截的配置 123456789&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/js/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/css/**&quot; /&gt; &lt;mvc:exclude-mapping path=&quot;/image/**&quot; /&gt; &lt;bean id=&quot;commonInterceptor&quot; class=&quot;org.shop.interceptor.CommonInterceptor&quot;&gt;&lt;/bean&gt; &lt;!--这个类就是我们自定义的Interceptor --&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 或者在web.xml中配置 12345678&lt;!-- 不拦截静态文件 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/js/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/images/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/fonts/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;]]></content>
      <categories>
        <category>spring mvc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：深入分布式缓存 从原理到实践]]></title>
    <url>%2F2019%2F03%2F27%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[读书笔记，简单记录读书过程中的主要知识点 第一章 缓存为王1.几个概念 1.缓存: 存储在计算机上的一个原始数据复制集， 以便于访问。 2.CPU的缓存: 指位于CPU与内存之间的临时存储器,容量比内存小得多但交换速度却比内存要快得多. 3.影响用户体验的因素: 使用者的状态、系统性能、环境 4.系统性能的指标一般包括: 响应时间、延迟时间、吞吐量、并发用户数和资源利用率等. 5.响应时间: 是指系统对用户请求做出响应的时间， 与人对软件性能的主观感受是非常一致的， 它完整地记录了整个系统处理请求的时间. 响应时间通常是指该软件系统所有功能的平均响应时间或者所有功能中的最大响应时间。 响应时间: 可继续划分为 “呈现时间” 和“系统响应时间”。 呈现时间: 指客户端在接收到系统数据时呈现页面所需的时间， 系统响应时间: 指服务端接收到用户请求到客户端接收到服务器发来的数据所需的时间。系统响应时间可进一步划分: 网络传输时间和应用延迟时间.前者是指数据在客户端和服务器端进行传输的时间， 而后者是指系统实际处理请求所需的时间。 6.吞吐量: 是指系统在单位时间内处理请求的数量. 7.并发用户数: 是指系统可以同时承载的正常使用系统功能的用户数量。 8.资源利用率: 反映的是在一段时间内资源平均被占用的情况。 2.缓存分类 缓存分类总结图 多级缓存系统 第二章分布式系统理论待读…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019年新年起始]]></title>
    <url>%2F2019%2F01%2F01%2F20190101%2F</url>
    <content type="text"><![CDATA[今天是2019年的新年第一天, 2018年已成往事, 重整身心, 继续出发. … 希望一切安好…开心, 顺心.💝]]></content>
      <categories>
        <category>心灵记事</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring系统架构与源码解读笔记]]></title>
    <url>%2F2018%2F12%2F23%2Fspring%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一. spring系统架构spring总共大约有20个模块, 由1300多个文件构成. 这些组件被分别整合在以下6个模块集合中: - 核心容器(Core Container) - AOP(Aspect Oriented Programming) - 设备支持(Instrumentaion) - 数据访问与集成(Data Access/Integration) - Web - 报文发送(Messaging) - Test 具体如下图: spring家族的依赖关系图如下: 二. spring IOC核心体系结构- 1.BeanFactory *一切从Bean开始* Spring Bean的创建是典型的工厂模式,这一系列的Bean工厂, (即IOC容器), 为开发者管理对象之间的依赖关系提供了很多遍历和基础服务, 我们常用的启动spring的类: ClassPathXmlApplication也是一个BeanFactory, 其继承关系图如下:]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里面试: 一个http请求,springMvc是如何找到对应的方法进行执行的?]]></title>
    <url>%2F2018%2F12%2F05%2F%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95-%E4%B8%80%E4%B8%AAhttp%E8%AF%B7%E6%B1%82-springMvc%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[最近在看spring mvc的相关源码,写了一个mvc框架小demo, 正好今天看到这个面试题,就把相关的只是点记录一下:还不够详细…回头看完了源码,再补充…. 1.启动时方法的注册判断读过spring源码的同学应该都知道, spring在项目启动时, 会扫描所有的类, 为他们创建对应的bean并放进容器,其实, spring mvc原理也一样,在项目启动时, 扫描所有的类的时候,会判断每个类上是否有相应的注解(如@controller,@service,@repository等),会判断每个类上是否有controller和requestMapping注解,然后把他们的方法拿到注册中心(detectHandlerMethods())进行注册.. 详细源码看图: 图1中 isHandler()方法的判断原则:把他们的方法拿到注册中心(detectHandlerMethods())进行注册,源码:对应图1中的detectHandlerMethods()图3中的 registerHandlerMethod()方法 2.怎么注册?遍历类中所有的方法 放到一个map,然后遍历map,然后判断哪些带有requestMapping注解,然后注册到注册中心 (registerHandlerMethod() =&gt; mappingRegistry.registry(mapping,handler,method))MappingRegistry这个注册中心定义了一堆final类型的map,,,比如urlLookup这个map,就是记录这个url地址应该由哪个方法进行处理的. 3.调用的时候呢.通过getHandlerInternal(request) 获取地址url,(getUrlPathHelper.getLookupPathForRequest)然后到注册中心去找对应的方法去执行 更多源码说明看完补充…]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>springMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手写mvc框架]]></title>
    <url>%2F2018%2F11%2F26%2Fmyself-MVC%2F</url>
    <content type="text"><![CDATA[自己动手写mvc框架 最近在看自己spring源码和mvc相关的课程,于是就把相关的笔记记在了这里…. 一. spring源码的核心组件: IOC AOP 1.IOC容器: 负责实例化, 定位, 配置应用程序中的对象及建立这些对象之间的依赖.比如对orderService的生命周期的管理. 当服务器(如tomcat)启动时—&gt;进行加载项目—&gt;spring会把所有的Bean全部创建出来,放进IOC容器. IOC容器就是一个很大的map对象. 源码为证: [图片] IOC: Map: map.put(key,val); key就是声明的beanName, value就是new Obj(); 当使用bean时, 就是从容器中get(&quot;beanName&quot;), 返回保存的bean实例. AOP面向切面编程,通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术 二. MVC核心类: DispatherServlet它继承了httpServlet, 它就是一个servlet 阅读笔记 未完待续….]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程过程调用（RPC）的原理与要考虑的问题]]></title>
    <url>%2F2018%2F08%2F20%2F%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8(RPC)%E5%8E%9F%E7%90%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一. 相关概念:1.本地函数调用: 系统是单体应用时,调用接口可以直接new对象,然后调用方法即可.因为在同一个内 存,即同一个地址空间,所以通过方法栈和参数就可实现. 2.远程过程调用:在分布式系统中,每个模块功能在不同的服务器上,再想调用某个方法,就不行了,因为本地没有那个类. 比如: 想收快递,自己在家时可以自己去接收, 这是本地方法调用; 自己不在家,可以让家中老婆接收,这就好比远程调用. 手机就好比一个代理,代理你发送通讯.进行远程通讯(远程调用).也许你会说, 可以模仿B/S架构的调用方式,B服务暴露一个restful接口,然后A服务调用这个restful接口间接调用某个方法. 嗯, 这已经很接近RPC了. 不过,这样每次都需要写一串发送http请求的代码,比如:httpClient.sendRequest..之类的, 最好的方式:是像本地调用一样,让使用者感受不到远程调用的过程, 就像这样: 你会说,可以用代理模式呀, 而且最好和spring IOC一起用,通过注入calculator对象,如果扫描到对象加了一个@reference注解,就给他生成一个代理对象.将代理对象放进容器, 代理对象内部就是通过httpClient来实现RPC远程过程调用的. 二. RPC原理上面这段就是很多RPC框架要解决的问题和解决的原理. 比如dubbo __↑ 三 .RPC要解决的问题:1.分布式系统中,服务之间的调用问题. 2.远程调用时,能像本地调用一样方便,让调用者感知不到远程调用的逻辑 四. RPC实现实际上,RPC很少用到http协议进行数据传输,毕竟只想传输一下数据,何必动用一个文本传输的应用层协议呢, 直接用二进制传输多好,比如直接用java的socket协议. 不管用何种协议进行数据传输，一个完整的RPC过程，都可以用下面这张图来描述： 以左边的Client端为例，Application就是rpc的调用方，Client Stub就是我们上面说到的代理对象，也就是那个看起来像是Calculator的实现类，其实内部是通过rpc方式来进行远程调用的代理对象，至于Client Run-time Library，则是实现远程调用的工具包，比如jdk的Socket，最后通过底层网络实现实现数据的传输。 这个过程中最重要的就是序列化和反序列化了，因为数据传输的数据包必须是二进制的，你直接丢一个Java对象过去，人家不认识，你必须把Java对象序列化为二进制格式，传给Server端，Server端接收到之后，再反序列化为Java对象。 1.目前拥有RMI，webservice，基于http协议的http Client 等成熟方案, 五. 不同协议实现RPC的区别：1.基于TCP协议 实现的RPC由于处于协议栈底层，可更灵活的对协议字段进行定制，减少网络传输字节数，降低网络开销，提高性能，但需要关注底层实现细节，代码量高，由于所定义协议的局限，平台和社区支持性好，难以实现跨平台调用，不同的终端需要开发不同的工具包来进行请求发送和响应解析，工作量大， 2.基于http协议 实现的RPC可以使用json和xml格式的响应数据，且作为通用格式标准，开源的工具相对成熟，开发简单； 通过代码优化和使用gzip数据压缩，能缩小与tcp传输性能的差距，所以具有很大优势 3.RESTful风格与RPC1.这两者并不是一个维度的概念，总得来说RPC涉及的维度更广.如果硬要比较，那么可以从RPC风格的url和Restful风格的url上进行比较。 比如你提供一个查询订单的接口，用RPC风格，你可能会这样写： /queryOrder?orderId=123 用Restful风格可以这样写:Get: /order?orderId=123 甚至更精炼:/order/123 2.RPC是面向过程，Restful是面向资源，并且使用了Http动词。 从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。 4.RPC 与 RMI 的区别严格来说这两者也不是一个维度的。 RMI: 是Java提供的一种访问远程对象的协议，是已经实现好了，可以直接用了。 RPC:只是一种编程模型，并没有规定你具体要怎样实现，你甚至都可以在你的RPC框架里面使用RMI来实现数据的传输，比如Dubbo 六:RPC要考虑的问题要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。 如果是分布式,一个服务可能有多个实例，在调用时，要如何获取这些实例的地址呢？ 这时就需要一个服务注册中心，比如在Dubbo里头，就可以使用Zookeeper作为注册中心，在调用时，从Zookeeper获取服务的实例列表，再从中选择一个进行调用。 选哪个调用好呢？这时候就需要负载均衡了，于是你又得考虑如何实现负载均衡，比如Dubbo就提供了好几种负载均衡策略。 还有，总不能每次调用时都去注册中心查询实例列表吧，这样效率很低，于是又有了缓存，有了缓存，就要考虑缓存更新问题，等等。 客户端不能每次调用完都干等着服务端返回数据吧，于是就要支持异步调用； 服务端的接口被修改了，老的接口还有人在用，怎么办？总不能让他们都改了吧？这就需要版本控制了； 服务端总不能每次接到请求都马上启动一个线程去处理吧？于是就需要线程池； 服务端关闭时，还没处理完的请求怎么办？是直接结束呢，还是等全部请求处理完再关闭呢？ 等等……..如此种种，都是一个优秀的RPC框架需要考虑的问题。 该篇笔记来源于一篇帖子的整理，，具体的帖子地址忘了留存。。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github pages + hexo构建自己的博客网站]]></title>
    <url>%2F2018%2F08%2F19%2F%E4%BD%BF%E7%94%A8githubPage%E4%B8%8Ehexo%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 本文章只对github pages + hexo构建博客网站做简要指导, 请做好以下软件安装准备工作… 一.准备工作1.安装git下载地址 2.安装node下载地址 3.注册一个github帐号注册地址, 至于github怎么连通使用, 请自行百度, 本文章不做指导. 二.使用hexo构建博客网站1.安装hexo1$ npm install -g hexo-cli 2.初始化hexo打开git bash, 执行如下代码:1$ hexo init [folder] 说明: 最好新建一个空文件夹, 切换到该目录执行hexo init 命令, 也可以使用 [folder] 参数指定一个路径作为你的博客目录. 3.本地服务启动hexo init完成之后, 一个简单的博客网站就完成了, ,并且自带了主题, 可以在本地启动hexo服务进行预览博客了.执行如下代码:1$ hexo server 说明: 如果报如下错误, 应是hexo server模块没有安装,12$ hexo serverUsage: hexo &lt;command&gt; 执行如下代码安装hexo server:12$ npm install hexo-server --save或者:npm i hexo-server 重新执行hexo server即可, 启动之后, 默认运行在4000端口, 打开浏览器,输入: http://localhost:4000 即可预览。。。如果端口被占用,执行: hexo -p 5000 server ,换成5000端口重新运行即可. 三.发布到github1.新建仓库在你的github新建一个仓库, 仓库名格式必须是: username.github.io, username就是你的github账号名称. 2.建立关联创建完成之后, 复制你的仓库地址,然后打开你博客目录下的_config.yml文件，拉倒最下面，修改deploy为以下代码:1234deploy: type: git repository: git@github.com:peterzhen40/peterzhen40.github.io.git branch: master 注: repository后面就是你刚才复制的仓库地址, 每个分号(“:”)后面有一个英文空格. 3.部署hexo部署到git我们需要安装hexo-deployer-git插件, 执行如下命令:1npm install hexo-deployer-git --save 执行如下命令进行部署:1$ hexo d ##部署,该命令等同于: hexo deploy 部署完成之后, 就可以在 http://username.github.io 地址进行访问了…以后的部署就是这三步了:123$ hexo clean ##清除已经生成的静态页面, $ hexo g ##重新生成静态页面, 该命令等同于: hexo generate$ hexo d ##部署,该命令等同于: hexo deploy 说明:发布到github只需使用上面的hexo d 命令即可, 不要把本地源码发布到github, (如:IDEA本地local change的变动不用管,hexo会帮我们把生成的博客自动提交的) 四.其他相关1.更换主题hexo初始化默认自带一个主题, 名为: landscape, 如果不喜欢, 可以更换. 可以去 主题 找一个自己喜欢的主题, 找到他的仓库地址, 复制仓库地址. 切换到你的博客目录下的/themes/目录下, 执行如下代码: 1$ git clone &quot;你复制的仓库地址&quot; ##即把主题下载下来 找到博客目录下的 _config.yml 文件, 修改theme, theme后面就是你下载的主题名称,(注意分号后面有个英文空格, 比如我的是: theme: hexo-theme-next) 2. hexo常用命令①.新建一个博客文件1hexo new [layout] &quot;name&quot; 会在source/_posts/下生成一个名叫”name”的md文件, 就是你新建的博客.说明: [layout]用来指定文章的布局，默认是post, hexo默认有三种布局，每种布局的路径不同： 布局 路径 post source/_posts page source draft source/_drafts ②.新建一个分类模块1$ hexo new page categories -你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类, type设置为”categories”-打开主题配置文件_config.yml 找到menu，将categorcies取消注释-要把文章归入分类只需在写文章时,在的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中,如:12title: 分类测试文章标题categories: 分类名 ③.添加标签模块1$ hexo new page tags -同上, 你会发现source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签, type设置为”tags”-打开主题配置文件_config.yml, 找到menu，将tags取消注释-给文章添加标签, 只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中 ④.添加关于模块1$ hexo new page about -同上, 你会发现source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息。-打开 主题配置文件 找到menu，将about取消注释 ⑤.添加搜索功能安装 hexo-generator-searchdb 插件1$ npm install hexo-generator-searchdb --save -打开 站点配置文件 找到Extensions在下面添加下面信息:123456# 搜索search: path: search.xml field: post format: html limit: 10000 ⑥添加阅读全文按钮这个很简单, 只需在文章结尾添加:1&lt;!--more--&gt; 这样, 更多的文章内容就不会显示了，只能点击阅读全文才能看… ⑦修改文章内超链接样式打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; ⑧设置网站缩略图标把你的图标文件（png或jpg格式，不是ico文件）放在主题目录themes/next/source/images里，然后打开主题配置文件_config.yml, 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 ⑨去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开主题配置文件，找到number, 设置为false即可, 如下:123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 更多hexo知识请查看 hexo官方文档更多主题配置, 请查看主题设置更多hexo插件, 请查看hexo插件 3.markdown语法自己百度去学习吧… 部署遇到的问题 在webstorm/IDEA中部署若出现以下错误 12345Error: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决: 一般使用git bash窗口进行部署就没有问题了, 会弹出密码框, 输入创建ssh时的密码即可]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
